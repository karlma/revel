---
root: .
title: The Revel Web Framework for Go
---
<!DOCTYPE html>
<html lang="en">
  <head>
    {% include head.html %}
    <link href="{{ page.root }}/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="{{ page.root }}/js/prettify.js" type="text/javascript"></script>
    <script src="{{ page.root }}/js/lang-go-rich.js" type="text/javascript"></script>
    {% include analytics.html %}
  </head>

  <body onload="prettyPrint()">
    <a href="https://github.com/robfig/revel">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index:1000;"
           src="img/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>

    {% include topnav.html %}

    <header class="hero-unit">
      <div class="container">
        <div class="row" style="margin-left:-50px;">
          <div class="hero-img"><img src="img/RevelWhiteLines.png" height="500" width="350"></div>
          <div class="hero-text">
            <h1>Revel</h1>
            <p>高生产率的go语言web框架.</p>
            <p>注：此站的内容从<a href="http://robfig.github.io/revel">原站</a>翻译而来，有翻译上的问题请联系：karlcpp@gmail.com</p>
          </div>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="page-header">
        <h1>特性</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>热代码加载</h2>
          <p>
            编辑，保存，刷新。  Revel为你编译代码和模板，所以你就不会断片啦。
            什么？代码不能编译？ 它会给你一个有帮助的
            <a href="img/CompilationError.png">描述</a>。
            什么？运行时panic？  Revel 能让你<a href="img/Panic.png">恢复的</a>。
          </p>
        </div>
        <div class="span4">
          <h2>全面的功能</h2>
          <p>
            Revel 所提供的
            <a href="manual/routing.html">路由</a>,
            <a href="manual/binding.html">参数解析</a>,
            <a href="manual/validation.html">验证</a>,
            <a href="manual/sessionflash.html">会话/flash</a>,
            <a href="manual/templates.html">模板</a>,
            <a href="manual/cache.html">缓存</a>,
            <a href="manual/jobs.html">job running</a>,
            <a href="manual/testing.html">测试框架</a>,
            甚至还有<a href="manual/i18n-messages.html">国际化</a>.
          </p>
        </div>
        <div class="span4">
          <h2>高性能</h2>
          <p>
            Revel建构在Go HTTP server之上, 这个东西<a href="http://www.techempower.com/benchmarks/#section=data-r5">
            最近的在基准服务</a>的各种负载测试中处理的请求数是Rails的<b>3到10倍</b>。
          </p>
        </div>
      </div>
      <div class="page-header">
        <h1>框架设计</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>同步</h2>
          <p>
            <a href="http://golang.org/pkg/net/http/">Go HTTP server</a>
            会在单独的
            <a href="http://golang.org/doc/effective_go.html#goroutines">goroutine</a>里处理每一次请求。
            写一个简单的callback-free代码一点都不感到内疚。
          </p>
        </div>
        <div class="span4">
          <h2>无状态</h2>
          <p>
            为了可预知的扩展性，Revel提供保持web层无状态的原语
            例如，session数据通过cookie方式保存在用户端，而cache则是用后端的内存缓存群集来实现。
          </p>
        </div>
        <div class="span4">
          <h2>模块化</h2>
          <p>
            Revel通过<b>filter</b>处理几乎所有的服务请求。filter是一组中间件。
            开发者可以自由的定制的自己的filter来替换默认的filter（如：实现一个定制的路由filter）。
          </p>
        </div>
      </div>
      <div class="row">
      </div>
      <section id="quickstart">
        <div class="page-header">
          <h1>快速入门</h1>
        </div>
        <div class="row">
          <div class="span6">
            <p>
              Revel自带了一些示例应用，算是为在真实世界中使用revel提供的例子吧。
            </p>
            <p>
              要运行这些个程序，你需要安装<a href="http://golang.org/doc/install">Go 1.1</a>。
            </p>
            <p>
              右边的命令会做以下事情：
              <ol>
                <li>将Revel安装在你的GOPATH目录里
                <li>生成Revel命令行工具
                <li>运行例子应用：Chat
              </ol>
              一旦它运行起来，在浏览器中打开
              <a href="http://localhost:9000/">http://localhost:9000/</a>， 然后
              <a href="samples/chat.html">读一下chat的实现代码吧</a>。
            </p>
          </div>
          <div class="span6" style="vertical-align:bottom;">
            <pre>
  go get github.com/robfig/revel/revel
  revel run github.com/robfig/revel/samples/chat
            </pre>
          </div>
        </div>
      </section>

      <section id="development">
        <div class="page-header">
          <h1>开发状态<small>应用早期。  欢迎下载试用。</small></h1>
        </div>
        <p>
          开发正在接近"final" 1.0的设计目标，但修改率仍然很高。如果您能搭把手的话，我们求之不得。
        </p>
        <p style="font-weight:bold;">
          加入到我们的<a href="https://groups.google.com/forum/#!forum/revel-framework">Google Group</a>
          就可以参与设计与开发工作，或者在IRC
          <a href="http://webchat.freenode.net/?channels=revel&amp;uio=d4">Freenode #revel</a>中参与。
          你也可以加入<a href="https://groups.google.com/group/revel-framework-announce">
          我们的公告表</a>，这样你就可以获得最新发布的消息啦。
        </p>
        <p>
          <a href="https://twitter.com/revelframework" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @revelframework</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

          <a href="https://twitter.com/share" class="twitter-share-button" data-via="revelframework" data-size="large" data-count="none" data-hashtags="golang">Tweet</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </p>
      </section>

      <section id="teaser">
        <div class="page-header">
          <h1>预览</h1>
        </div>
        <p>
          这一节先让你尝尝Revel框架各部分的味道：
        </p>

        <dl class="dl-horizontal">
          <dt><a href="#routing">路由</a></dt>
          <dd>简单的声明式语法。类型安全的反向路由。</dd>

          <dt><a href="#controllers">控制器</a></dt>
          <dd>
            Revel将endpoints组织进控制器里. 它们则提供了简单的数据绑定和表单验证。
          </dd>

          <dt><a href="#templates">模板</a></dt>
          <dd>Revel使得Go模板更简单易用。</dd>

          <dt><a href="#interceptors">拦截器</a></dt>
          <dd>
            在action执行前或执行后注册的函数。它们可以在每一个控制器中使用。
          </dd>

          <dt><a href="#filters">过滤器</a></dt>
          <dd>
            更多的通用功能可以通过过滤器实现。
          </dd>

        </dl>

        <div class="row">
          <div class="span6">
            <h2 id="routing">路由</h2>
            <p>
              Revel使用声明式路由语法。它通过一个单一的文件中集中了所有的一个应用的所有路由，
              通过一个简单的语法来匹配请求，提取URI中的参数，并为action指定特定路由的参数。
              下面是一个例子...
            </p>
          </div>
          <div class="span12">
            <pre>
# conf/routes
# 这个文件定义了所以应用的路由（按优先级从高到低的顺序排列）
GET    /login                Application.Login       <b># 一个简单路径</b>
GET    /hotels/              Hotels.Index            <b># 匹配尾部带斜杠和不带斜杠的情况</b>
GET    /hotels/:id           Hotels.Show             <b># 提取一个嵌入的参数</b>
WS     /hotels/:id/feed      Hotels.Feed             <b># WebSockets.</b>
POST   /hotels/:id/:action   Hotels.:action          <b># 自己路由到action.</b>
GET    /public/*filepath     Static.Serve("public")  <b># 从/public/里取出静态资源...</b>
*      /:controller/:action  :controller.:action     <b># 所以其他情况; 自动生成 URL</b></pre>

          </div>
          <div class="span6">
						<p>
							以类型安全的方式产生反向路由.  例如:
						</p>
          </div>
          <div class="span12">
            <pre class="prettyprint lang-go">
// Show the hotel information.
func (c Hotels) Show(id int) revel.Result {
	hotel := HotelById(id)
	return c.Render(hotel)
}

// Save the updated hotel information and redirect back to Show.
func (c Hotels) Save(hotel Hotel) revel.Result {
	// validate and save hotel
	return c.Redirect(<b>routes.Hotels.Show(hotel.Id)</b>)
}</pre>
					</div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="controllers">Controllers</h2>
            <p>
              All Actions are methods on a Controller.  This teaser shows a couple cool things:
              <ul>
                <li> <b>Data binding.</b>  Revel binds simple values and structs from
                  the URL or form and passes them as parameters to your method.
                  (If you prefer to access them directly from a parameter map, that's ok too!)
                <li> <b>Validation.</b> Helpers to manage validation errors.
                <li> <b>Flash.</b> The flash is a cookie that lives for one
                  request (errors, success messages, etc).
                <li> <b>Session.</b> The session is a cryptographically signed
                  cookie, exposed as a <code>map[string]string</code>.
                <li> <b>Results.</b> Redirections take advantage of reverse
                  routing.  Template rendering makes your data available using the
                  name of the local variable!
              </ul>

              Here's an example:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-go">
// app/controllers/app.go

type Application struct {
	*revel.Controller
}

func (c Application) Register() revel.Result {
	title := "Register"
	return c.Render(title)
}

func (c Application) SaveUser(user models.User, verifyPassword string) revel.Result {
	c.Validation.Required(verifyPassword)
	c.Validation.Required(verifyPassword == user.Password)
		Message("Password does not match")
	user.Validate(c.Validation)

	if c.Validation.HasErrors() {
		c.Validation.Keep()
		c.FlashParams()
		return c.Redirect(routes.Application.Register())
	}

	user.HashedPassword, _ = bcrypt.GenerateFromPassword(
		[]byte(user.Password), bcrypt.DefaultCost)
	err := c.Txn.Insert(&user)
	if err != nil {
		panic(err)
	}

	c.Session["user"] = user.Username
	c.Flash.Success("Welcome, " + user.Name)
	return c.Redirect(routes.Hotels.Index())
}
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="templates">Templates</h2>
            <p>
              By convention, Revel manages to integrate
              <a href="http://golang.org/pkg/text/template/">Go Templates</a>
              easily into the rest of the web app. Here is part of the template
              rendered in the <b>Register</b> action shown above.
            </p>
            Note that:
            <ul>
              <li> Revel found it automatically using the name of the action.
              <li> <b>field</b> is a simple helper function that returns a map
                of validation errors and parameter values for the named field.
                The app may inject any helper funcs that it wants.
              <li> The <b>title</b> variable is available in the template as if
                it had been explicitly put in the RenderArgs.  (It's used in
                <a href="http://github.com/robfig/revel/samples/booking/app/views/header.html">
                  header.html</a> in this case)
            </ul>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-html">{% capture teaser_template %}{% raw %}
{{/* app/views/Application/Register.html */}}

{{template "header.html" .}}

<h1>Register:</h1>
<form action="/register" method="POST">
  {{with $field := field "user.Username" .}}
    <p class="{{$field.ErrorClass}}">
      <strong>Username:</strong>
      <input type="text" name="{{$field.Name}}" size="16" value="{{$field.Flash}}"> *
      <span class="error">{{$field.Error}}</span>
    </p>
  {{end}}

  {{/* other fields */}}

  <p class="buttons">
    <input type="submit" value="Register"> <a href="/">Cancel</a>
  </p>
</form>

{{template "footer.html" .}}{% endraw %}{% endcapture %}{{ teaser_template|escape }}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="interceptors">Interceptors</h2>
            <p>
              Interceptors are controller methods that are run before or after
              requests, or in response to panics.  By embedding a controller
              into another, a developer can share interceptors and fields across
              many controllers.
            </p>
						<p>
							As an example, the database module may be used to open a
							connection on initialization, made available through a global
							handle.  Additionally, embedding the <b>db.Transactional</b> type
							adds a <b>sql.Txn</b> field plus interceptors that begin and commit
							transactions (or rollback on panic).
						</p>
						<p>
							Here's what the interceptor looks like (minus error handling):
						</p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/robfig/revel/modules/db/app/db.go

var Db *sql.DB

func Init() {
	// Read configuration.
	Driver, _ = revel.Config.String("db.driver")
	Spec, _ = revel.Config.String("db.spec")

	// Open a connection.
	Db, _ = sql.Open(Driver, Spec)
}

// Transactional adds transaction management to your controller.
type Transactional struct {
	*revel.Controller
	Txn *sql.Tx
}

func (c *Transactional) Begin() revel.Result {
	c.Txn, _ = Db.Begin()
	return nil
}

func (c *Transactional) Commit() revel.Result {
	_ = c.Txn.Commit()
	c.Txn = nil
	return nil
}

func (c *Transactional) Rollback() revel.Result {
	_ = c.Txn.Rollback()
	c.Txn = nil
	return nil
}

func init() {
	revel.InterceptMethod((*Transactional).Begin, revel.BEFORE)
	revel.InterceptMethod((*Transactional).Commit, revel.AFTER)
	revel.InterceptMethod((*Transactional).Rollback, revel.PANIC)
}</pre>

						<p>
							Here is how it can be mixed in to an application controller:
						</p>

            <pre class="prettyprint">
type Bookings struct {
	*revel.Controller
	db.Transactional  // Adds .Txn
	user.Login        // Adds .User
}

func (c Bookings) ShowFirstBooking() revel.Result {
	row := c.Txn.QueryRow(`
select id, hotel_id, user_id, price, nights
  from Booking
 where UserId = ?
 limit 1`, c.User.Id)
	...
	return c.Render(booking)
}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="filters">Filters</h2>
            <p>
              Filters are the middleware of the application.  They are simply
              funcs with a specific signature:
            </p>
            <pre class="prettyprint">
type Filter func(c *Controller, filterChain []Filter)</pre>
            <p>
              Even complicated "built-in" functionality like the interceptor
              framework is implemented as a filter:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/robfig/revel/intercept.go

var InterceptorFilter = func(c *Controller, fc []Filter) {
	defer invokeInterceptors(FINALLY, c)
	defer func() {
		if err := recover(); err != nil {
			invokeInterceptors(PANIC, c)
			panic(err)
		}
	}()

	// Invoke the BEFORE interceptors and return early, if we get a result.
	invokeInterceptors(BEFORE, c)
	if c.Result != nil {
		return
	}

	fc[0](c, fc[1:])
	invokeInterceptors(AFTER, c)
}</pre>
						<p>
							Revel provides a default stack of Filters which the developer can
							override.  This makes it easy for the developer to select exactly
							the parts of the framework that they want to use.
						</p>

            <pre class="prettyprint">
// github.com/robfig/revel/filter.go

// Filters is the default set of global filters.
// It may be set by the application on initialization.
var Filters = []Filter{
	PanicFilter,             // Recover from panics and display an error page instead.
	RouterFilter,            // Use the routing table to select the right Action
	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.
	ParamsFilter,            // Parse parameters into Controller.Params.
	SessionFilter,           // Restore and write the session cookie.
	FlashFilter,             // Restore and write the flash cookie.
	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.
	I18nFilter,              // Resolve the requested language
	InterceptorFilter,       // Run interceptors around the action.
	ActionInvoker,           // Invoke the action.
}
						</pre>

						<p>
							Nearly all framework functionality is implemented in the filters,
							and the filter stack is directly exposed to the developer as part
							of the configuration.  This makes Revel understandable and modular.
						</p>
						<p>
							As proof of modularity, look how simple
							the <a href="https://github.com/robfig/revel/blob/master/server.go">
								main server handler</a> is:
						</p>
            <pre class="prettyprint">
// github.com/robfig/revel/server.go

func handleInternal(w http.ResponseWriter, r *http.Request, ws *websocket.Conn) {
	var (
		req  = NewRequest(r)
		resp = NewResponse(w)
		c    = NewController(req, resp)
	)
	req.Websocket = ws

	Filters[0](c, Filters[1:])
	if c.Result != nil {
		c.Result.Apply(req, resp)
	}
}</pre>
          </div>
				</div>
      </section>

      <section id="wishlist">
        <div class="page-header">
          <h1>Wishlist</h1>
        </div>
        <p>
          There are some areas that could benefit from some TLC.
        </p>
        <ul>
          <li> <b>ORM</b> -- Presently Revel is BYOORM (bring-your-own-ORM).  A
            good ORM integration would make simple things simple.
            (e.g. <a href="http://github.com/coopernurse/gorp">gorp</a>,
            <a href="https://github.com/eaigner/hood">hood</a>,
            <a href="https://github.com/coocood/qbs">qbs</a>,
            <a href="https://github.com/eaigner/jet">jet</a>,
            <a href="https://github.com/astaxie/beedb">beedb</a>,
            <a href="https://github.com/gosexy/db">gosexy</a>,
            <a href="https://github.com/jinzhu/gorm">gorm</a>)
          <li> <b>Pluggable template loader</b> -- Presently only Go templates
          are supported by Revel (although the developer could use their own
          library independently).  Providing an interface that makes any
          template language pluggable would be ideal.
        </ul>
      </section>

      <hr>

      <footer>
        <p>MIT License</p>
        <p>
          Gopher images remixed from those produced by
          <a href="http://www.golang.org">Go team</a>.
        </p>
      </footer>

    </div> <!-- /container -->
  </body>
</html>
