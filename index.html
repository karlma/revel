---
root: .
title: The Revel Web Framework for Go
---
<!DOCTYPE html>
<html lang="en">
  <head>
    {% include head.html %}
    <link href="{{ page.root }}/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="{{ page.root }}/js/prettify.js" type="text/javascript"></script>
    <script src="{{ page.root }}/js/lang-go-rich.js" type="text/javascript"></script>
    {% include analytics.html %}
  </head>

  <body onload="prettyPrint()">
    <a href="https://github.com/robfig/revel">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index:1000;"
           src="img/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>

    {% include topnav.html %}

    <header class="hero-unit">
      <div class="container">
        <div class="row" style="margin-left:-50px;">
          <div class="hero-img"><img src="img/RevelWhiteLines.png" height="500" width="350"></div>
          <div class="hero-text">
            <h1>Revel</h1>
            <p>高生产率的go语言web框架.</p>
            <p>注：此站的内容从<a href="http://robfig.github.io/revel">原站</a>翻译而来，有翻译上的问题请联系：karlcpp@gmail.com</p>
          </div>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="page-header">
        <h1>特性</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>热代码加载</h2>
          <p>
            编辑，保存，刷新。  Revel为你编译代码和模板，所以你就不会断片啦。
            什么？代码不能编译？ 它会给你一个有帮助的
            <a href="img/CompilationError.png">描述</a>。
            什么？运行时panic？  Revel 能让你<a href="img/Panic.png">恢复的</a>。
          </p>
        </div>
        <div class="span4">
          <h2>全面的功能</h2>
          <p>
            Revel 所提供的
            <a href="manual/routing.html">路由</a>,
            <a href="manual/binding.html">参数解析</a>,
            <a href="manual/validation.html">验证</a>,
            <a href="manual/sessionflash.html">会话/flash</a>,
            <a href="manual/templates.html">模板</a>,
            <a href="manual/cache.html">缓存</a>,
            <a href="manual/jobs.html">job running</a>,
            <a href="manual/testing.html">测试框架</a>,
            甚至还有<a href="manual/i18n-messages.html">国际化</a>.
          </p>
        </div>
        <div class="span4">
          <h2>高性能</h2>
          <p>
            Revel建构在Go HTTP server之上, 这个东西<a href="http://www.techempower.com/benchmarks/#section=data-r5">
            最近的在基准服务</a>的各种负载测试中处理的请求数是Rails的<b>3到10倍</b>。
          </p>
        </div>
      </div>
      <div class="page-header">
        <h1>框架设计</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>同步</h2>
          <p>
            <a href="http://golang.org/pkg/net/http/">Go HTTP server</a>
            会在单独的
            <a href="http://golang.org/doc/effective_go.html#goroutines">goroutine</a>里处理每一次请求。
            写一个简单的callback-free代码一点都不感到内疚。
          </p>
        </div>
        <div class="span4">
          <h2>无状态</h2>
          <p>
            为了可预知的扩展性，Revel提供保持web层无状态的原语
            例如，session数据通过cookie方式保存在用户端，而cache则是用后端的内存缓存群集来实现。
          </p>
        </div>
        <div class="span4">
          <h2>模块化</h2>
          <p>
            Revel通过<b>filter</b>处理几乎所有的服务请求。filter是一组中间件。
            开发者可以自由的定制的自己的filter来替换默认的filter（如：实现一个定制的路由filter）。
          </p>
        </div>
      </div>
      <div class="row">
      </div>
      <section id="quickstart">
        <div class="page-header">
          <h1>快速入门</h1>
        </div>
        <div class="row">
          <div class="span6">
            <p>
              Revel自带了一些示例应用，算是为在真实世界中使用revel提供的例子吧。
            </p>
            <p>
              要运行这些个程序，你需要安装<a href="http://golang.org/doc/install">Go 1.1</a>。
            </p>
            <p>
              右边的命令会做以下事情：
              <ol>
                <li>将Revel安装在你的GOPATH目录里
                <li>生成Revel命令行工具
                <li>运行例子应用：Chat
              </ol>
              一旦它运行起来，在浏览器中打开
              <a href="http://localhost:9000/">http://localhost:9000/</a>， 然后
              <a href="samples/chat.html">读一下chat的实现代码吧</a>。
            </p>
          </div>
          <div class="span6" style="vertical-align:bottom;">
            <pre>
  go get github.com/robfig/revel/revel
  revel run github.com/robfig/revel/samples/chat
            </pre>
          </div>
        </div>
      </section>

      <section id="development">
        <div class="page-header">
          <h1>开发状态<small>应用早期。  欢迎下载试用。</small></h1>
        </div>
        <p>
          开发正在接近"final" 1.0的设计目标，但修改率仍然很高。如果您能搭把手的话，我们求之不得。
        </p>
        <p style="font-weight:bold;">
          加入到我们的<a href="https://groups.google.com/forum/#!forum/revel-framework">Google Group</a>
          就可以参与设计与开发工作，或者在IRC
          <a href="http://webchat.freenode.net/?channels=revel&amp;uio=d4">Freenode #revel</a>中参与。
          你也可以加入<a href="https://groups.google.com/group/revel-framework-announce">
          我们的公告表</a>，这样你就可以获得最新发布的消息啦。
        </p>
        <p>
          <a href="https://twitter.com/revelframework" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @revelframework</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

          <a href="https://twitter.com/share" class="twitter-share-button" data-via="revelframework" data-size="large" data-count="none" data-hashtags="golang">Tweet</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </p>
      </section>

      <section id="teaser">
        <div class="page-header">
          <h1>预览</h1>
        </div>
        <p>
          这一节先让你尝尝Revel框架各部分的味道：
        </p>

        <dl class="dl-horizontal">
          <dt><a href="#routing">路由</a></dt>
          <dd>简单的声明式语法。类型安全的反向路由。</dd>

          <dt><a href="#controllers">控制器</a></dt>
          <dd>
            Revel将endpoints组织进控制器里. 它们则提供了简单的数据绑定和表单验证。
          </dd>

          <dt><a href="#templates">模板</a></dt>
          <dd>Revel使得Go模板更简单易用。</dd>

          <dt><a href="#interceptors">拦截器</a></dt>
          <dd>
            在action执行前或执行后注册的函数。它们可以在每一个控制器中使用。
          </dd>

          <dt><a href="#filters">过滤器</a></dt>
          <dd>
            更多的通用功能可以通过过滤器实现。
          </dd>

        </dl>

        <div class="row">
          <div class="span6">
            <h2 id="routing">路由</h2>
            <p>
              Revel使用声明式路由语法。它通过一个单一的文件中集中了所有的一个应用的所有路由，
              通过一个简单的语法来匹配请求，提取URI中的参数，并为action指定特定路由的参数。
              下面是一个例子...
            </p>
          </div>
          <div class="span12">
            <pre>
# conf/routes
# 这个文件定义了所以应用的路由（按优先级从高到低的顺序排列）
GET    /login                Application.Login       <b># 一个简单路径</b>
GET    /hotels/              Hotels.Index            <b># 匹配尾部带斜杠和不带斜杠的情况</b>
GET    /hotels/:id           Hotels.Show             <b># 提取一个嵌入的参数</b>
WS     /hotels/:id/feed      Hotels.Feed             <b># WebSockets.</b>
POST   /hotels/:id/:action   Hotels.:action          <b># 自己路由到action.</b>
GET    /public/*filepath     Static.Serve("public")  <b># 从/public/里取出静态资源...</b>
*      /:controller/:action  :controller.:action     <b># 其他情况; 自动生成 URL</b></pre>

          </div>
          <div class="span6">
						<p>
							以类型安全的方式产生反向路由.  例如:
						</p>
          </div>
          <div class="span12">
            <pre class="prettyprint lang-go">
// Show the hotel information.
func (c Hotels) Show(id int) revel.Result {
	hotel := HotelById(id)
	return c.Render(hotel)
}

// Save the updated hotel information and redirect back to Show.
func (c Hotels) Save(hotel Hotel) revel.Result {
	// validate and save hotel
	return c.Redirect(<b>routes.Hotels.Show(hotel.Id)</b>)
}</pre>
					</div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="controllers">控制器</h2>
            <p>
              所有Action都是控制器(Controller)的一个方法。这一做法同时带来了数个很酷的事：
              <ul>
                <li> <b>数据绑定(Data binding).</b>  Revel从URL或表单里绑定简单值或结构，并把它们以参数的方式传递到你的方法中。
                  (如果你喜欢从参数map中直接读取它们，可能也没有问题!)
                <li> <b>验证(Validation).</b> Helpers管理验证错误。
                <li> <b>Flash.</b> Flash是一个只在一次请求中使用的cookie(错误，成功消息等).
                <li> <b>Session.</b> Session是一个加密的签名cookie，以<code>map[string]string</code>的形式存在。
                <li> <b>结果(Results).</b> 重定向利用了反向路由。在模块渲染时，你的数据可以通过本地变量访问。
              </ul>

              这有个例子：
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-go">
// app/controllers/app.go

type Application struct {
	*revel.Controller
}

func (c Application) Register() revel.Result {
	title := "Register"
	return c.Render(title)
}

func (c Application) SaveUser(user models.User, verifyPassword string) revel.Result {
	c.Validation.Required(verifyPassword)
	c.Validation.Required(verifyPassword == user.Password)
		Message("Password does not match")
	user.Validate(c.Validation)

	if c.Validation.HasErrors() {
		c.Validation.Keep()
		c.FlashParams()
		return c.Redirect(routes.Application.Register())
	}

	user.HashedPassword, _ = bcrypt.GenerateFromPassword(
		[]byte(user.Password), bcrypt.DefaultCost)
	err := c.Txn.Insert(&user)
	if err != nil {
		panic(err)
	}

	c.Session["user"] = user.Username
	c.Flash.Success("Welcome, " + user.Name)
	return c.Redirect(routes.Hotels.Index())
}
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="templates">模板</h2>
            <p>
              按照惯例，Revel在web app的其余部分很容易的整合了<a href="http://golang.org/pkg/text/template/">Go Templates</a>
              这里就是上述<b>Register</b> action所渲染的模板的部分代码。
            </p>
            注意：
            <ul>
              <li> Revel通过action的名字自动找到模板。
              <li> <b>field</b> 是一个简单的helper功能，它返回一个与字段名对应的验证错误和参数值的map。
                App可以根据需要注入任务helper功能。
              <li>变量<b>title</b>是模板中是可见的，即使它是被显式的放在RenderAgrs中的。 (它在这个例子的
                <a href="http://github.com/robfig/revel/samples/booking/app/views/header.html">
                  header.html</a> 中用到)
            </ul>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-html">{% capture teaser_template %}{% raw %}
{{/* app/views/Application/Register.html */}}

{{template "header.html" .}}

<h1>Register:</h1>
<form action="/register" method="POST">
  {{with $field := field "user.Username" .}}
    <p class="{{$field.ErrorClass}}">
      <strong>Username:</strong>
      <input type="text" name="{{$field.Name}}" size="16" value="{{$field.Flash}}"> *
      <span class="error">{{$field.Error}}</span>
    </p>
  {{end}}

  {{/* other fields */}}

  <p class="buttons">
    <input type="submit" value="Register"> <a href="/">Cancel</a>
  </p>
</form>

{{template "footer.html" .}}{% endraw %}{% endcapture %}{{ teaser_template|escape }}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="interceptors">拦截器</h2>
            <p>
              拦截器是控制器的方法，在request之前或之后，或者在response的panic里。
              通过将一个控制器嵌入到其它控制器的方法，开发者可以跨多个控制器共享拦截器和字段。
            </p>
	    <p>
              例如，数据库模块通常在初始化时打开数据库连接，通过一个全局handle使其可用。
              另外，有一个用于嵌入的<b>db.Transactional</b>类型，这个类型中有一个<b>sql.Txn</b>字段，
              并且有三个拦截器方法:begin（BEFORT）,commit（AFTER）,rollback（PANIC）。
              译注：其它控制器可以通过嵌入这个db.Transactional类型而获得这三个拦截器。
	    </p>
	    <p>
              下面是拦截器的样子（最小出错处理）：
	    </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/robfig/revel/modules/db/app/db.go

var Db *sql.DB

func Init() {
	// Read configuration.
	Driver, _ = revel.Config.String("db.driver")
	Spec, _ = revel.Config.String("db.spec")

	// Open a connection.
	Db, _ = sql.Open(Driver, Spec)
}

// Transactional adds transaction management to your controller.
type Transactional struct {
	*revel.Controller
	Txn *sql.Tx
}

func (c *Transactional) Begin() revel.Result {
	c.Txn, _ = Db.Begin()
	return nil
}

func (c *Transactional) Commit() revel.Result {
	_ = c.Txn.Commit()
	c.Txn = nil
	return nil
}

func (c *Transactional) Rollback() revel.Result {
	_ = c.Txn.Rollback()
	c.Txn = nil
	return nil
}

func init() {
	revel.InterceptMethod((*Transactional).Begin, revel.BEFORE)
	revel.InterceptMethod((*Transactional).Commit, revel.AFTER)
	revel.InterceptMethod((*Transactional).Rollback, revel.PANIC)
}</pre>

						<p>
                                                  下面是一个应用控制器如何混入(mix in)的例子：
						</p>

            <pre class="prettyprint">
type Bookings struct {
	*revel.Controller
	db.Transactional  // Adds .Txn
	user.Login        // Adds .User
}

func (c Bookings) ShowFirstBooking() revel.Result {
	row := c.Txn.QueryRow(`
select id, hotel_id, user_id, price, nights
  from Booking
 where UserId = ?
 limit 1`, c.User.Id)
	...
	return c.Render(booking)
}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="filters">过滤器</h2>
            <p>
              过滤器是应用中间件。它们是一些规定格式的简单func。
            </p>
            <pre class="prettyprint">
type Filter func(c *Controller, filterChain []Filter)</pre>
            <p>
              基至复杂的 "built-in" 功能，像拦截器框架也是用过滤器实现的。
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/robfig/revel/intercept.go

var InterceptorFilter = func(c *Controller, fc []Filter) {
	defer invokeInterceptors(FINALLY, c)
	defer func() {
		if err := recover(); err != nil {
			invokeInterceptors(PANIC, c)
			panic(err)
		}
	}()

	// Invoke the BEFORE interceptors and return early, if we get a result.
	invokeInterceptors(BEFORE, c)
	if c.Result != nil {
		return
	}

	fc[0](c, fc[1:])
	invokeInterceptors(AFTER, c)
}</pre>
						<p>
                                                  Revel提供了一个默认的过滤器栈，开发者可以覆盖它。
                                                  这样的方式可以让开发者很容易的精确的选择他们想用的框架的某些部分。
						</p>

            <pre class="prettyprint">
// github.com/robfig/revel/filter.go

// Filters is the default set of global filters.
// It may be set by the application on initialization.
var Filters = []Filter{
	PanicFilter,             // Recover from panics and display an error page instead.
	RouterFilter,            // Use the routing table to select the right Action
	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.
	ParamsFilter,            // Parse parameters into Controller.Params.
	SessionFilter,           // Restore and write the session cookie.
	FlashFilter,             // Restore and write the flash cookie.
	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.
	I18nFilter,              // Resolve the requested language
	InterceptorFilter,       // Run interceptors around the action.
	ActionInvoker,           // Invoke the action.
}
						</pre>

						<p>
                                                  几乎所有的框架功能都是用过滤器实现的，而且过滤器做了配置的一部分直接暴露给开发者。
                                                  这使得Revel更容易理解，和更加模块化。
						</p>
						<p>
							做为Revel模块化的证据，看一下
							the <a href="https://github.com/robfig/revel/blob/master/server.go">
								主服务处理器</a> 是多么的简单:
						</p>
            <pre class="prettyprint">
// github.com/robfig/revel/server.go

func handleInternal(w http.ResponseWriter, r *http.Request, ws *websocket.Conn) {
	var (
		req  = NewRequest(r)
		resp = NewResponse(w)
		c    = NewController(req, resp)
	)
	req.Websocket = ws

	Filters[0](c, Filters[1:])
	if c.Result != nil {
		c.Result.Apply(req, resp)
	}
}</pre>
          </div>
				</div>
      </section>

      <section id="wishlist">
        <div class="page-header">
          <h1>意愿表</h1>
        </div>
        <p>
          有一些东西可能会有用<br>
        </p>
        <ul>
          <li> <b>ORM</b> -- 目前Revel是一个 BYOORM (bring-your-own-ORM).
            整合一个好的ORM也许会让简单的事情更加简单
            (e.g. <a href="http://github.com/coopernurse/gorp">gorp</a>,
            <a href="https://github.com/eaigner/hood">hood</a>,
            <a href="https://github.com/coocood/qbs">qbs</a>,
            <a href="https://github.com/eaigner/jet">jet</a>,
            <a href="https://github.com/astaxie/beedb">beedb</a>,
            <a href="https://github.com/gosexy/db">gosexy</a>,
            <a href="https://github.com/jinzhu/gorm">gorm</a>)
          <li> <b>插件式模板加载器</b> -- 目前Revel只支持Go模板（虽然开发者可以用他们自己的独立的库）。
            最好能提供一个可以让任何一种模板语言插件化的接口。
        </ul>
      </section>

      <hr>

      <footer>
        <p>MIT License</p>
        <p>
          Gopher images remixed from those produced by
          <a href="http://www.golang.org">Go team</a>.
        </p>
      </footer>

    </div> <!-- /container -->
  </body>
</html>
